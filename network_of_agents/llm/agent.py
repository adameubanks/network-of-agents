"""
LLM Agent class representing individual agents in the social network.
"""

import numpy as np
from typing import List, Dict, Any, Optional
from .litellm_client import LiteLLMClient


class LLMAgent:
    """
    Represents an individual LLM agent in the social network.
    """
    
    def __init__(self, 
                 agent_id: int,
                 persona: str,
                 initial_opinions: Optional[List[float]] = None,
                 topics: Optional[List[str]] = None,
                 llm_client: Optional[LiteLLMClient] = None):
        """
        Initialize an LLM agent.
        
        Args:
            agent_id: Unique identifier for the agent
            persona: Description of the agent's personality/background
            initial_opinions: Initial opinion vector (if None, will be generated by LLM)
            topics: List of topics for opinions
            llm_client: LiteLLM client for opinion generation
        """
        self.agent_id = agent_id
        self.persona = persona
        self.topics = topics or []
        self.llm_client = llm_client
        
        if initial_opinions is not None:
            self.opinions = np.array(initial_opinions)
        else:
            self.opinions = None
        
        self.opinion_history = []
        self.connection_history = []
        self.content_generated = []
    
    def initialize_opinions(self, topics: List[str], llm_client: LiteLLMClient) -> np.ndarray:
        """
        Initialize opinions using LLM if not already set.
        
        Args:
            topics: List of topics for opinions
            llm_client: LiteLLM client for opinion generation
            
        Returns:
            Initial opinion vector
        """
        if self.opinions is None:
            self.topics = topics
            self.llm_client = llm_client
            
            # Generate opinions using LLM
            opinion_values = llm_client.generate_opinion_vector(topics, self.persona)
            self.opinions = np.array(opinion_values)
        
        return self.opinions
    
    def update_opinions(self, new_opinions: np.ndarray):
        """
        Update the agent's opinions.
        
        Args:
            new_opinions: New opinion vector
        """
        # Store current opinions in history
        self.opinion_history.append(self.opinions.copy())
        
        # Update current opinions
        self.opinions = new_opinions.copy()
    
    def get_opinions(self) -> np.ndarray:
        """
        Get current opinion vector.
        
        Returns:
            Current opinion vector
        """
        return self.opinions.copy()
    
    def get_opinion_history(self) -> List[np.ndarray]:
        """
        Get opinion history.
        
        Returns:
            List of opinion vectors over time
        """
        return self.opinion_history.copy()
    
    def generate_content(self, llm_client: LiteLLMClient) -> str:
        """
        Generate content reflecting current opinions.
        
        Args:
            llm_client: LiteLLM client for content generation
            
        Returns:
            Generated content
        """
        if self.llm_client is None:
            self.llm_client = llm_client
        
        content = self.llm_client.analyze_converged_opinions(self.topics, self.opinions.tolist())
        self.content_generated.append(content)
        return content
    
    def get_similarity_to(self, other_agent: 'LLMAgent') -> float:
        """
        Calculate similarity to another agent based on opinions.
        
        Args:
            other_agent: Another LLM agent
            
        Returns:
            Similarity score (0-1)
        """
        # Use L1 norm for similarity calculation
        opinion_diff = np.linalg.norm(self.opinions - other_agent.opinions, ord=1)
        # Convert to similarity (1 - normalized difference)
        max_possible_diff = len(self.opinions)  # Maximum L1 norm for binary opinions
        similarity = 1 - (opinion_diff / max_possible_diff)
        return max(0.0, similarity)
    
    def get_degree(self, adjacency_matrix: np.ndarray) -> int:
        """
        Get the degree (number of connections) of this agent.
        
        Args:
            adjacency_matrix: Network adjacency matrix
            
        Returns:
            Number of connections
        """
        return int(np.sum(adjacency_matrix[self.agent_id, :]))
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert agent to dictionary for serialization.
        
        Returns:
            Dictionary representation of the agent
        """
        return {
            'agent_id': self.agent_id,
            'persona': self.persona,
            'topics': self.topics,
            'current_opinions': self.opinions.tolist() if self.opinions is not None else None,
            'opinion_history': [op.tolist() for op in self.opinion_history],
            'content_generated': self.content_generated
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LLMAgent':
        """
        Create agent from dictionary.
        
        Args:
            data: Dictionary representation of the agent
            
        Returns:
            LLM agent instance
        """
        agent = cls(
            agent_id=data['agent_id'],
            persona=data['persona'],
            initial_opinions=data['current_opinions'],
            topics=data['topics']
        )
        agent.opinion_history = [np.array(op) for op in data['opinion_history']]
        agent.content_generated = data['content_generated']
        return agent 